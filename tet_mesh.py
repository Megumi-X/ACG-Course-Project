##########################################################################################################################
# This file is a citation from the following repo: https://github.com/taodu-eecs/GraDy/blob/master/python/tet_mesh.py
# The original authors are Prof.Du and other contributors of the GraDy project.
# The citation has got permission from the original authors.
##########################################################################################################################

import numpy as np
def to_real_array(val):
    return np.array(val, dtype=np.float32).copy()

def to_integer_array(val):
    return np.array(val, dtype=np.int32).copy()

# Input:
# - node_file and ele_file: generated by tetgen.
# Output:
# - verts: n x 3.
# - elements: m x 4.
def load_tetgen_file(node_file, ele_file):
    with open(node_file, "r") as f:
        lines = f.readlines()
        lines = [l.strip().split() for l in lines]
        vert_num = int(lines[0][0])
        verts = to_real_array([[float(v) for v in lines[i + 1][1:4]] for i in range(vert_num)])

    with open(ele_file, "r") as f:
        lines = f.readlines()
        lines = [l.strip().split() for l in lines]
        ele_num = int(lines[0][0])
        elements = to_integer_array([[int(e) for e in lines[i + 1][1:5]] for i in range(ele_num)]) - 1

    return verts, elements

def save_tetgen_file(vertices, elements, node_file_name, ele_file_name):
    vertices = to_real_array(vertices)
    elements = to_integer_array(elements)

    # Reference: https://wias-berlin.de/software/tetgen/fformats.node.html.
    with open(node_file_name, "w") as f:
        f.write("{:d} 3 0 0\n".format(vertices.shape[0]))
        for i, (vx, vy, vz) in enumerate(vertices):
            f.write("{:d} {:f} {:f} {:f}\n".format(i + 1, vx, vy, vz))

    # Reference: https://wias-berlin.de/software/tetgen/fformats.ele.html.
    with open(ele_file_name, "w") as f:
        f.write("{:d} 4 0\n".format(elements.shape[0]))
        for i, (ei, ej, ek, ew) in enumerate(elements):
            f.write("{:d} {:d} {:d} {:d} {:d}\n".format(i + 1, ei + 1, ej + 1, ek + 1, ew + 1))

# Filter unreferenced vertices in a mesh.
# Input:
# - vertices: n x l.
# - elements: m x k.
# This function checks all rows in elements and generates a new (vertices, elements) pair such that all
# vertices are referenced.
import numpy as np

def filter_unused_vertices(vertices, elements):
    vertices = to_real_array(vertices)
    elements = to_integer_array(elements)
    vert_num = vertices.shape[0]

    used = [False] * vert_num
    for e in elements:
        for ei in e:
            used[ei] = True

    remap = np.ones(vert_num) * -1
    used_so_far = 0
    for idx, val in enumerate(used):
        if val:
            remap[idx] = used_so_far
            used_so_far += 1

    new_vertices = []
    for idx, val in enumerate(used):
        if val:
            new_vertices.append(vertices[idx])
    new_vertices = to_real_array(new_vertices)

    new_elements = []
    for e in elements:
        new_ei = [remap[ei] for ei in e]
        new_elements.append(new_ei)
    new_elements = to_integer_array(new_elements)
    return new_vertices, new_elements

# Given four vertices of a tet, return a 4 x 3 int arrays of 0, 1, 2, and 3. Each row describes
# a surface triangle whose normal is pointing outward if you follow the vertices by the righ-hand rule.
def fix_tet_faces(verts):
    verts = to_real_array(verts)
    v0, v1, v2, v3 = verts
    f = []
    if np.cross(v1 - v0, v2 - v1).dot(v3 - v0) < 0:
        f = [
            (0, 1, 2),
            (2, 1, 3),
            (1, 0, 3),
            (0, 2, 3),
        ]
    else:
        f = [
            (1, 0, 2),
            (1, 2, 3),
            (0, 1, 3),
            (2, 0, 3),
        ]
    return to_integer_array(f)

# Return a set of boundary vertex indices.
def get_boundary_vertices(vertices, elements):
    v = to_real_array(vertices)
    elements = to_integer_array(elements)

    face_dict = {}
    for fi in elements:
        element_vert = v[fi]
        face_idx = fix_tet_faces(element_vert)
        for f in face_idx:
            vidx = [int(fi[fij]) for fij in f]
            vidx_key = tuple(sorted(vidx))
            if vidx_key in face_dict:
                del face_dict[vidx_key]
            else:
                face_dict[vidx_key] = vidx

    boundary_vertices = set()
    for _, vidx in face_dict.items():
        for i in vidx:
            boundary_vertices.add(i)
    return boundary_vertices

# Return a list of boundary faces.
def get_boundary_faces(vertices, elements):
    v = to_real_array(vertices)
    elements = to_integer_array(elements)

    face_dict = {}
    for fi in elements:
        element_vert = v[fi]
        face_idx = fix_tet_faces(element_vert)
        for f in face_idx:
            vidx = [int(fi[fij]) for fij in f]
            vidx_key = tuple(sorted(vidx))
            if vidx_key in face_dict:
                del face_dict[vidx_key]
            else:
                face_dict[vidx_key] = vidx

    bnd_faces = []
    for _, vidx in face_dict.items():
        bnd_faces.append(list(vidx))
    return to_integer_array(bnd_faces)

# Given tet_mesh, return vert and faces that describes the surface mesh as a triangle mesh.
# You should use this function mostly for rendering.
# Output:
# - vertices: an n x 3 double array.
# - faces: an m x 3 integer array.
def tet2obj(vertices, elements, obj_file_name=None):
    v = to_real_array(vertices)
    elements = to_integer_array(elements)

    face_dict = {}
    for fi in elements:
        element_vert = v[fi]
        face_idx = fix_tet_faces(element_vert)
        for f in face_idx:
            vidx = [fi[fij] for fij in f]
            vidx_key = tuple(sorted(vidx))
            if vidx_key in face_dict:
                del face_dict[vidx_key]
            else:
                face_dict[vidx_key] = vidx

    f = []
    for _, vidx in face_dict.items():
        f.append(vidx)
    f = to_integer_array(f)

    v, f = filter_unused_vertices(v, f)

    if obj_file_name is not None:
        with open(obj_file_name, "w") as f_obj:
            for vv in v:
                f_obj.write("v {} {} {}\n".format(vv[0], vv[1], vv[2]))
            for ff in f:
                f_obj.write("f {} {} {}\n".format(ff[0] + 1, ff[1] + 1, ff[2] + 1))

    return v, f

# - vertices: an n x 3 double array.
# - faces: an m x 3 integer array.
def save_to_obj(vertices, faces, obj_file_name):
    v = to_real_array(vertices)
    f = to_integer_array(faces)

    with open(obj_file_name, "w") as f_obj:
        for vv in v:
            f_obj.write("v {} {} {}\n".format(vv[0], vv[1], vv[2]))
        for ff in f:
            f_obj.write("f {} {} {}\n".format(ff[0] + 1, ff[1] + 1, ff[2] + 1))

# Input:
# - triangle_mesh_file_name (obj, ply, etc). If normalize_input = True, it will be shifted and scaled so
#   that it is bounded by [-1, 1]^3.
# Output:
# - verts: an n x 3 double array of vertices.
# - elements: an m x 4 integer array of tets.
#   For each row in elements [i0, i1, i2, i3], we ensure that the normal of (i0, i1, i2) points outwards.
#   This also implies that i3 is on the other side of (i0, i1, i2).
import os
import tetgen
import trimesh
import pyvista as pv

def tetrahedralize(triangle_mesh_file_name, visualize=False, normalize_input=True, options=None):
    tri_mesh = trimesh.load(triangle_mesh_file_name)
    assert tri_mesh.is_watertight

    if normalize_input:
        bbx_offset = np.min(tri_mesh.vertices, axis=0)
        tri_mesh.vertices -= bbx_offset
        bbx_extent = to_real_array(tri_mesh.bounding_box.extents)
        tri_mesh.vertices /= np.max(bbx_extent)
        bbx_max = np.max(tri_mesh.vertices, axis=0)
        tri_mesh.vertices -= bbx_max / 2

    tmp_file_name = '.tmp.stl'
    tri_mesh.export(tmp_file_name)
    mesh = pv.read(tmp_file_name)
    os.remove(tmp_file_name)
    if visualize:
        mesh.plot()

    tet = tetgen.TetGen(mesh)
    tet.make_manifold()
    if options is None:
        nodes, elements = tet.tetrahedralize()
    else:
        nodes, elements = tet.tetrahedralize(**options)

    if visualize:
        for i in range(1, 10):
            tet_grid = tet.grid
            bbox_min = np.min(tri_mesh.vertices, axis=0)
            bbox_max = np.max(tri_mesh.vertices, axis=0)
            ratio = 0.1 * i
            bbx_center = (1 - ratio) * bbox_min + ratio * bbox_max
            # Plot half the tet.
            mask = tet_grid.points[:, 2] < bbx_center[2]
            half_tet = tet_grid.extract_points(mask)

            plotter = pv.Plotter()
            plotter.add_mesh(half_tet, color="w", show_edges=True)
            plotter.add_mesh(tet_grid, color="r", style="wireframe", opacity=0.2)
            plotter.show()

            plotter.close()

    # nodes is an n x 3 matrix.
    # elements is an m x 4 or m x 10 matrix. See this doc for details.
    # http://wias-berlin.de/software/tetgen/1.5/doc/manual/manual006.html#ff_ele.
    # In both cases, the first four columns of elements are the tets.
    nodes = to_real_array(nodes)
    elements_unsigned = to_integer_array(elements)[:, :4]

    # Fix the sign of elements if necessary.
    elements_unsigned = to_integer_array(elements_unsigned)
    v0 = nodes[elements_unsigned[:, 0]]
    v1 = nodes[elements_unsigned[:, 1]]
    v2 = nodes[elements_unsigned[:, 2]]
    v3 = nodes[elements_unsigned[:, 3]]
    flipped_flag = np.sum(np.cross(v1 - v0, v2 - v1) * (v3 - v0), axis=1) > 0
    elements_flipped = elements_unsigned[flipped_flag]
    elements_not_flipped = elements_unsigned[~flipped_flag]
    elements_flipped = np.vstack([
        elements_flipped[:, 0], elements_flipped[:, 2], elements_flipped[:, 1], elements_flipped[:, 3]
    ]).T
    elements = np.vstack([elements_flipped, elements_not_flipped])
    elements = to_integer_array(elements)
    return filter_unused_vertices(nodes, elements)

def pbrt2obj(pbrt_file_name, obj_file_name):
    with open(pbrt_file_name, "r") as p:
        lines = p.readlines()

        points = ""
        indices = ""
        point_region = False
        index_region = False
        for l in lines:
            l = l.strip()
            if "point3" in l:
                index_region = False
                points = l
                point_region = True
            elif "indices" in l:
                point_region = False
                indices = l
                index_region = True
            elif point_region:
                points += " " + l
            elif index_region:
                indices += " " + l

    # Now extract point and index information.
    points = points[points.find("[") + 1:points.find("]")].split()
    points = to_real_array([float(p) for p in points])
    indices = indices[indices.find("[") + 1:indices.find("]")].split()
    indices = to_integer_array([int(i) for i in indices])
    points = points.reshape((-1, 3))
    indices = indices.reshape((-1, 3))

    # Write the points and indices to .obj.
    with open(obj_file_name, "w") as f:
        for x, y, z in points:
            f.write("v {} {} {}\n".format(x, y, z))
        for i, j, k in indices:
            f.write("f {} {} {}\n".format(i + 1, j + 1, k + 1))